key512 = "MNdM6HS._mvBY_1M7U9KJitDXmPrWfXwXKy7J1T07C36NU2qquBtU4u9TkVhdd.h9ASZgEf0t6Eipx_VBYqKv_a5kj2wQ0.zrN1Yy5GcWQfw9XWtBByaO49ShrjNpdk8oXadA6Q0mXJro5X7UgGwZbJrOHjxXajP1bW1zAxo5X5AIs5mRq52H6tBG2t49c1S8CHaE4W6AGIvP.R6N97_.Tv_A1wnX5SnA8obXR56EIRHsDPsXCNS_4i_8W5o8j_0T3aZim3p8Xt5Uo4Hj9AX4ve31HIt4O16mI7X4uIDawG6tIdLXXsB19IyGp4Aiw5mkx5VcqE6IyXy_s2zNc3_qnmGD12D.X77t9Nx.f_6b4E0f97e5YHNfB3G1Q2mSajyDK9H2f_8.e.c3qG1Q2yGAQdR51Af2mA33b38UvzVQib6miNdwm__7ot6wCN76XVZbnMcpm4s8RoXlfG2W.w49h7FazlF48NNQ3eD7NL1VkDvB9Q1ej1L5COqW6s5oU.2M5_Pe5u77mL0dXFd9g_9ydC6SRrAs24xYi4MAk2zBf3PDS2d05W_3gS0vZbzIbzY5x37k2J0F2f8n9NVN06yD4iK1z3R_4lSm3yNb9mXxvyI31v13oV8.8uzwb99CsoI0kU9QxO_cJaO";
key255 = "4VuA5YfKJh6dszJMtD.C2Z1Pbo8QmGXI0vVtS7YR9FgwNnqWxyr36uVjUlkHei1VpBTSAROQNgIm8a7PZbMezkqXDE4JCL2dYrKHPjUlVbafwd_OyShu3JxZc.5MtF7ZjNIEX6U0Gv3bAeWnRYVLYDkU2sbO9moIlhXBp.i4CKJdPlS6NroEDtB0q1LWw_3cxVroBbH9NKPdUZQlThzPLJ7qaiVgWZQxJl7vPONXzf0A35FbVou8Cde5QF.mIFJl_ayc7WovY9_hSrA3m2by6K0Xt1_Y8kp5uDhnE7NlV.1UaFDuMIRlGsQ2mufn0iZrYkzVyMNBWoXKq15eAP89h.L5OT46Cczfs9DaE2uQPUxlkVqU.7GbR_0K3jwNJX4tvY8xgHkpDqO6_9.nhQjJmBm.u7N0X1LO3ZI8e.q7sSyd7GAvPcPY4g21kP";
key200 = "LPb4AfJlWntVCY2d.RU3eDzmIuk6HsB97g8MT5LZxXyvQrPpFw1iGK0oqNhEacSj_OhDfWYRbgJ2UV39oKC4_Tm1I7Xl6ZNJSPv_kA8qziVBF3MeGtRDu.5QXxwqYNdPjBO6cKf2y7rIAHlW1EbTgKVvMsS8R0nXhjzYk9uONp3c4J2UzLeD1ZqI6.qWm7m_5XdbRLHaC8PQsf1vUi9TJrCoQkZtvu0LDV6Y.iyNFZx4yYsM9.dUKWGPYJAE2NlOc3VhxznTDfHnBuXeKog3iYXpawO5XPR_4";
key117 = "x5qBFluNPscTKvJ0S2_m.wReLtbM17kqIEUYjZrG3D8VgWi6OHh9oYzXpCQAFd4yjn2aVf4Kc8WBJRuIPZo3NQh_";
key71 = "dFJ7Xqy6P.TK53vQOhEzrmB9fW1VwSgboJ2UuAM0eHk8pYnCRIcLjZaN4iDsK_2lGtNX_";
key36 = "W1lK7ZiQsM4B9dUv3r6L0O8hJtN5XpEw._2yFg";
key7 = "fA6D2zR";
alp1 = "iZF4dTAXV3E7zwWyoP9mBGYOMhxl0frSeRJCp2a18kbg5N6UQDjLsvKHuqnIct._";
alp2 = "lfVCDXTJHojaKyiNM490d8RvwPAnZeUBQcuqsbLSpz1Y3g2khFG75EO6ImxWtr._";
alp3 = "VQAZDIbHqUtT64ikdJMRnsW1Poz90NpKCaw7yEegOYc2Sj3uLBvmXGxh5lFr8f._";
alp4 = "5CXHAJpaj2DwIWYn36cogliREUd1z4vM0VuOTrqxySf9eBLPtZb8mFNGQskhK7._";
alp5 = "cH5UhndwG3ZymTA0sWNrqIVKLotvMY7bl8JiEC29fPSB6DuaOQ4zFxk1pRXejg._";
alp6 = "goPuXQFJleyztHbs4W1MpGEAYVhRv6jnkUO2mrKx0S5Li39BIDw8f7ZdqTaCcN._";
alp7 = "DHK4zUCblGtamFjoBIp1uP7yfW98MOvVQnq6c5Zr2kJL0wgTehNsEi3xXYSdRA._";
alp8 = "mG6dwyrlWVqN9H7D8zAJEYORks4L5M23ZcKxeBQSCPUFpn1jhXI0vgitboTuaf._";
alp9 = "EArwRS3OJBG16mQ7CILMfYdTyqp9XWU2Di5btuv4FjgnKPksc0Nhxo8VaeHzlZ._";
alp10 = "9JgBT7YGFpmkbLE4HeWSNrow5hlAPUcQsOvqK36x8zifyC0V1nMajtdXI2RDuZ._";
alp11 = "pVNr9GEq4msWn0t2KdHxoSQ6kjelF3DJb8aPOwXZ5gyIYiLzUT7c1BfuRMChvA._";
alp12 = "34FOqCYoZruc0l2hLVmW6vikdf8HDjzXSQpxJUKAREtaG5yB9sgbMP7neTIwN1._";
alp13 = "KlTRbBfWQY6IF2CsgHAoEqp78Uya0e5ZJS43Pkh1DLtrm9uwzNGcjivMndVXxO._";
alp14 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._";
//64: 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63
/*let alph1 = {"a": 1, "b": 2, "c": 3, "d": 4, "e": 5, "f": 6, "g": 7, "h": 8, "i": 9, "j": 10, "k": 11, "l": 12, "m": 13, "n": 14, "o": 15, "p": 16, "q": 17, "r": 18, "s": 19, "t": 20, "u": 21, "v": 22, "w": 23, "x": 24, "y": 25, "z": 26, "A": 27, "B": 28, "C": 29, "D": 30, "E": 31, "F": 32, "G": 33, "H": 34, "I": 35, "J": 36, "K": 37, "L": 38, "M": 39, "N": 40, "O": 41, "P": 42, "Q": 43, "R": 44, "S": 45, "T": 46, "U": 47, "V": 48, "W": 49, "X": 50, "Y": 51, "Z": 52, "0": 53, "1": 54, "2": 55, "3": 56, "4": 57, "5": 58, "6": 59, "7": 60, "8": 61, "9": 62, ".": 63, "_": 64};
let alph2 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._';*/
let alpf1 = {"a": 1, "b": 2, "c": 3, "d": 4, "e": 5, "f": 6, "g": 7, "h": 8, "i": 9, "j": 10, "k": 11, "l": 12, "m": 13, "n": 14, "o": 15, "p": 16, "q": 17, "r": 18, "s": 19, "t": 20, "u": 21, "v": 22, "w": 23, "x": 24, "y": 25, "z": 26, "A": 27, "B": 28, "C": 29, "D": 30, "E": 31, "F": 32, "G": 33, "H": 34, "I": 35, "J": 36, "K": 37, "L": 38, "M": 39, "N": 40, "O": 41, "P": 42, "Q": 43, "R": 44, "S": 45, "T": 46, "U": 47, "V": 48, "W": 49, "X": 50, "Y": 51, "Z": 52, "0": 53, "1": 54, "2": 55, "3": 56, "4": 57, "5": 58, "6": 59, "7": 60, "8": 61, "9": 62, ".": 63, "_": 64, "-": 65, "~": 66};
let alpf2 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._-~';
//alph2 = alph2.split("");
const a1 = [3, 5, 7, 9, 11, 13, 15, 17, 19, 21];
const a2 = [23, 25, 27, 29, 31, 33, 35, 37, 39, 41];
const a3 = [43, 45, 47, 49, 51, 53, 55, 57, 59, 61];
function sani(input) {
    return input.replace(/[^a-zA-Z0-9\s.]/g, '');
}
function reverseString(str) {
    return str.split("").reverse().join("");
}
function encryptRailFence(text, key) {
  let rail = new Array(key).fill().map(() => new Array(text.length).fill('\n'));
  let dir_down = false;
  let row = 0, col = 0;
  for (let i = 0; i < text.length; i++) {
    if (row == 0 || row == key - 1) dir_down = !dir_down;
    rail[row][col++] = text[i];
    dir_down ? row++ : row--;
  }
  let result = '';
  for (let i = 0; i < key; i++)
    for (let j = 0; j < text.length; j++)
      if (rail[i][j] != '\n') result += rail[i][j];
  return result;
}
function decryptRailFence(cipher, key) {
  let rail = new Array(key).fill().map(() => new Array(cipher.length).fill('\n'));
  let dir_down = false;
  let row = 0, col = 0;
  for (let i = 0; i < cipher.length; i++) {
    if (row == 0) dir_down = true;
    if (row == key - 1) dir_down = false;
    rail[row][col++] = '*';
    dir_down ? row++ : row--;
  }
  let index = 0;
  for (let i = 0; i < key; i++)
    for (let j = 0; j < cipher.length; j++)
      if (rail[i][j] == '*' && index < cipher.length) rail[i][j] = cipher[index++];
  let result = '';
  row = 0, col = 0;
  for (let i = 0; i < cipher.length; i++) {
    if (row == 0) dir_down = true;
    if (row == key - 1) dir_down = false;
    if (rail[row][col] != '*') result += rail[row][col++];
    dir_down ? row++ : row--;
  }
  return result;
}
function modInverse(a, m) {
    for (let x = 1; x < m; x++) {
        if ((a * x) % m === 1) {
            return x;
        }
    }
    return 1;
}
function mod(n, m) {
  return ((n % m) + m) % m;
}
function affineEncrypt(text, a, b, alph1, alph2) {
	let re = ""
	let res = "";
	for (let i = 0; i < text.length; i++) {
		re = alph1[text[i]];
		re = a*re;
		re += b;
		re = mod(re, 64);
		if(re == undefined){
			re = 0
		}
		re -= 1;
		if(re == -1){
			re = 63;
		}
		res += alph2[re];
	};
	return res;
}
function affineDecrypt(text, a, b, alph1, alph2) {
	let re = "";
	let res = "";
	for (let i = 0; i < text.length; i++) {
		inva = modInverse(a, 64);
		re = Number(alph1[text[i]]);
		re = Number(re) - Number(b);
		re = re*inva;
		re = mod(re, 64);
		if(re == undefined){
			re = 0
		}
		re -= 1;
		if(re == -1){
			re = 63;
		}
		res += alph2[re];
	}
	return res;
}
function chunk(str, size) {
    return str.match(new RegExp('.{1,' + size + '}', 'g'));
}
function autoe(text, tkey, key, alph1, alph2) {
	tkey += text;
	key += text;
	tkey = tkey.split("");
	key = key.split("");
	text = text.split("");
	let at = [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63];
	for (let i = 0; i < text.length; i++) {
		a = alph1[tkey[i]] % 31;
		b = alph1[key[i]] % 64;
		text[i] = affineEncrypt(text[i], at[a], b, alph1, alph2);
	}
	text = text.join('');
	return text;
}
function autod(text, tkey, key, alph1, alph2) {
	tkey = tkey.split("");
	key = key.split("");
	text = text.split("");
	let at = [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63];
	for (let i = 0; i < text.length; i++) {
		a = alph1[tkey[i]] % 31;
		b = alph1[key[i]] % 64;
		text[i] = affineDecrypt(text[i], at[a], b, alph1, alph2);
		tkey.push(text[i]);
		key.push(text[i]);
	}
	text = text.join('');
	return text;
}

function repkey(text, key){
	key += key;
	if(key < text){
		repkey(text, key);
	}
	else{
		return key;
	}
}
function autore(text, tkey, key, alph1, alph2) {
	rkey = repkey(text, key);
	tkey += text;
	key += text;
	tkey = tkey.split("");
	key = key.split("");
	text = text.split("");
	let at = [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63];
	for (let i = 0; i < text.length; i++) {
		a = alph1[tkey[i]] % 31;
		b = alph1[key[i]] % 64;
		text[i] = affineEncrypt(text[i], at[a], b, alph1, alph2);
		rkeyi = alph1[rkey[i]] % 5;
		rkeyi += 2;
		text = encryptRailFence(text, rkeyi);
	}
	text = text.join('');
	return text;
}
function autord(text, tkey, key, alph1, alph2) {
	rkey = repkey(text, key);
	rkey = rkey.substring(0, text.length);
	rkey = reverseString(rkey);
	tkey = tkey.split("");
	key = key.split("");
	text = text.split("");
	let at = [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63];
	for (let i = 0; i < text.length; i++) {
		rkeyi = alph1[rkey[i]] % 5;
		rkeyi += 2;
		text = decryptRailFence(text, rkeyi);
		a = alph1[tkey[i]] % 31;
		b = alph1[key[i]] % 64;
		text[i] = affineDecrypt(text[i], at[a], b, alph1, alph2);
		tkey.push(text[i]);
		key.push(text[i]);
	}
	text = text.join('');
	return text;
}

function cte(text, ckey){
	let length = ckey.length;
	let nekey = ckey.split('').sort().join('');
	let newkey = {};
	let result = chunk(text, length);
	let re = "";
	for (let i = 0; i < ckey.length; i++) {
		newkey[ckey[i]] = "";
		for (let j = 0; j < result.length; j++) {
			if(result[j][i] != undefined){
				newkey[ckey[i]] += result[j][i];
			}
		}
	}
	for (let i = 0; i < nekey.length; i++) {
		re += newkey[nekey[i]];
	}
	return re;
}
function ctd(text, ckey){
	let length = ckey.length;
	let tlength = text.length;
	let nekey = {};
	let rem = tlength % length;
	let low = Math.floor(tlength/length);
	let ss = 0;
	let se = 0;
	let okeyl = {};
	let skey = ckey.split('').sort().join('');
	for (let i = 0; i < ckey.length; i++) {
		okeyl[ckey[i]] = low;
		if(rem > 0){
			rem = rem - 1;
			okeyl[ckey[i]] += 1;
		}
	}
	for (let i = 0; i < skey.length; i++) {
		se = ss + okeyl[skey[i]];
		nekey[skey[i]] = text.substring(ss, se);
		ss = se;
	}
	let re = "";
	for (let j = 0; j < nekey[ckey[0]].length; j++) {
		for (let i = 0; i < ckey.length; i++) {
			if(nekey[ckey[i]][j] != undefined){
				re += nekey[ckey[i]][j];
			}
		}
	}
	return re;
}
function bife(text, key, nkey, ckey, alph1, alph2){
	let at = [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63];
	let b = 0;
	for (let i = 0; i < nkey.length; i++) {
		b += nkey[i];
	}
	b = b % 64;
	let ai = key.length % 31;
	let a = at[ai];
	let starter = affineEncrypt(alph2, a, b, alph1, alph2);
	for (let i = 0; i < ckey.length; i++) {
		starter = starter.replace(ckey[i], '');
		starter = ckey[i] + starter;
	}
	let tempckey = Array.from(new Set(text.split(''))).join("");
	let tempckey2 = "";
	if(text.length >= 4){
		tempckey = text.substring(0, 4);
		tempckey2 = reverseString(text);
		tempckey2 = tempckey2.substring(0, 7);
	}
	starter = chunk(starter, 1);
	psq = {};
	psqn = {};
	let q = 0;
	for (let i = 0; i < 8; i++) {
		psq[i] = [];
		for (let j = 0; j < 8; j++) {
			psq[i][j] = starter[q];
			psqn[starter[q]] = [i,j];
			q = q + 1;
		}
	}
	let r1 = "";
	let r2 = "";
	let r = "";
	for (let i = 0; i < text.length; i++) {
		r1 += psqn[text[i]][0];
		r2 += psqn[text[i]][1];
	}
	r = r1 + r2;
	r = chunk(r, 2);
	let fin = "";
	let temp = "";
	for (let i = 0; i < r.length; i++) {
		tmp = r[i];
		fin += psq[tmp[0]][tmp[1]];
	}
	return fin;
}
function trie(text, key, nkey, ckey, alph1, alph2){
	let at = [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63];
	let b = 0;
	for (let i = 0; i < nkey.length; i++) {
		b += nkey[i];
	}
	b = b % 64;
	let ai = key.length % 31;
	let a = at[ai];
	let starter = affineEncrypt(alph2, a, b, alph1, alph2);
	for (let i = 0; i < ckey.length; i++) {
		starter = starter.replace(ckey[i], '');
		starter = ckey[i] + starter;
	}
	let tempckey = Array.from(new Set(text.split(''))).join("");
	let tempckey2 = "";
	if(text.length >= 4){
		tempckey = text.substring(0, 4);
		tempckey2 = reverseString(text);
		tempckey2 = tempckey2.substring(0, 7);
	}
	starter = chunk(starter, 1);
	psq = {};
	psqn = {};
	let q = 0;
	for (let i = 0; i < 4; i++) {
		psq[i] = [];
		for (let j = 0; j < 4; j++) {
			psq[i][j] = [];
			for (let y = 0; y < 4; y++) {
				psq[i][j][y] = starter[q];
				psqn[starter[q]] = [i,j,y];
				q = q + 1;
			}
		}
	}
	let r1 = "";
	let r2 = "";
	let r3 = "";
	let r = "";
	for (let i = 0; i < text.length; i++) {
		r1 += psqn[text[i]][0];
		r2 += psqn[text[i]][1];
		r3 += psqn[text[i]][2];
	}
	r = r1 + r2 + r3;
	r = chunk(r, 3);
	let fin = "";
	let temp = "";
	for (let i = 0; i < r.length; i++) {
		tmp = r[i];
		fin += psq[tmp[0]][tmp[1]][tmp[2]];
	}
	return fin;
}
function sene(text, key, nkey, ckey, alph1, alph2){
	let at = [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63];
	let b = 0;
	for (let i = 0; i < nkey.length; i++) {
		b += nkey[i];
	}
	b = b % 64;
	let ai = key.length % 31;
	let a = at[ai];
	let starter = affineEncrypt(alph2, a, b, alph1, alph2);
	for (let i = 0; i < ckey.length; i++) {
		starter = starter.replace(ckey[i], '');
		starter = ckey[i] + starter;
	}
	let tempckey = Array.from(new Set(text.split(''))).join("");
	let tempckey2 = "";
	if(text.length >= 4){
		tempckey = text.substring(0, 4);
		tempckey2 = reverseString(text);
		tempckey2 = tempckey2.substring(0, 7);
	}
	starter = chunk(starter, 1);
	psq = {};
	psqn = {};
	let q = 0;
	for (let i = 0; i < 2; i++) {
		psq[i] = [];
		for (let j = 0; j < 2; j++) {
			psq[i][j] = [];
			for (let y = 0; y < 2; y++) {
				psq[i][j][y] = [];
				for (let h = 0; h < 2; h++) {
					psq[i][j][y][h] = [];
					for (let x = 0; x < 2; x++) {
						psq[i][j][y][h][x] = [];
						for (let z = 0; z < 2; z++) {
							psq[i][j][y][h][x][z] = starter[q];
							psqn[starter[q]] = [i,j,y,h,x,z];
							q = q + 1;
						}
					}
				}
			}
		}
	}
	let r1 = "";
	let r2 = "";
	let r3 = "";
	let r4 = "";
	let r5 = "";
	let r6 = "";
	let r = "";
	for (let i = 0; i < text.length; i++) {
		r1 += psqn[text[i]][0];
		r2 += psqn[text[i]][1];
		r3 += psqn[text[i]][2];
		r4 += psqn[text[i]][3];
		r5 += psqn[text[i]][4];
		r6 += psqn[text[i]][5];
	}
	r = r1 + r2 + r3 + r4 + r5 + r6;
	r = chunk(r, 6);
	let fin = "";
	let temp = "";
	for (let i = 0; i < r.length; i++) {
		tmp = r[i];
		fin += psq[tmp[0]][tmp[1]][tmp[2]][tmp[3]][tmp[4]][tmp[5]];
	}
	return fin;
}
function send(text, key, nkey, ckey, alph1, alph2){
	let at = [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63];
	let b = 0;
	for (let i = 0; i < nkey.length; i++) {
		b += nkey[i];
	}
	b = b % 64;
	let ai = key.length % 31;
	let a = at[ai];
	let starter = affineEncrypt(alph2, a, b, alph1, alph2);
	for (let i = 0; i < ckey.length; i++) {
		starter = starter.replace(ckey[i], '');
		starter = ckey[i] + starter;
	}
	let tempckey = Array.from(new Set(text.split(''))).join("");
	let tempckey2 = "";
	if(text.length >= 4){
		tempckey = text.substring(0, 4);
		tempckey2 = reverseString(text);
		tempckey2 = tempckey2.substring(0, 7);
	}
	starter = chunk(starter, 1);
	psq = {};
	psqn = {};
	let q = 0;
	for (let i = 0; i < 2; i++) {
		psq[i] = [];
		for (let j = 0; j < 2; j++) {
			psq[i][j] = [];
			for (let y = 0; y < 2; y++) {
				psq[i][j][y] = [];
				for (let h = 0; h < 2; h++) {
					psq[i][j][y][h] = [];
					for (let x = 0; x < 2; x++) {
						psq[i][j][y][h][x] = [];
						for (let z = 0; z < 2; z++) {
							psq[i][j][y][h][x][z] = starter[q];
							psqn[starter[q]] = [i,j,y,h,x,z];
							q = q + 1;
						}
					}
				}
			}
		}
	}
	r = "";
	for (let i = 0; i < text.length; i++) {
		r += psqn[text[i]].join("");
	}
	r = chunk(r, text.length);
	let fin = "";
	for (let i = 0; i < text.length; i++) {
		fin += psq[r[0][i]][r[1][i]][r[2][i]][r[3][i]][r[4][i]][r[5][i]];
	}
	return fin;
}
function trid(text, key, nkey, ckey, alph1, alph2){
	let at = [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63];
	let b = 0;
	for (let i = 0; i < nkey.length; i++) {
		b += nkey[i];
	}
	b = b % 64;
	let ai = key.length % 31;
	let a = at[ai];
	let starter = affineEncrypt(alph2, a, b, alph1, alph2);
	for (let i = 0; i < ckey.length; i++) {
		starter = starter.replace(ckey[i], '');
		starter = ckey[i] + starter;
	}
	let tempckey = Array.from(new Set(text.split(''))).join("");
	let tempckey2 = "";
	if(text.length >= 4){
		tempckey = text.substring(0, 4);
		tempckey2 = reverseString(text);
		tempckey2 = tempckey2.substring(0, 7);
	}
	starter = chunk(starter, 1);
	psq = {};
	psqn = {};
	let q = 0;
	for (let i = 0; i < 4; i++) {
		psq[i] = [];
		for (let j = 0; j < 4; j++) {
			psq[i][j] = [];
			for (let y = 0; y < 4; y++) {
				psq[i][j][y] = starter[q];
				psqn[starter[q]] = [i,j,y];
				q = q + 1;
			}
		}
	}
	r = "";
	for (let i = 0; i < text.length; i++) {
		r += psqn[text[i]].join("");
	}
	r = chunk(r, text.length);
	let fin = "";
	for (let i = 0; i < text.length; i++) {
		fin += psq[r[0][i]][r[1][i]][r[2][i]];
	}
	return fin;
}
function bifd(text, key, nkey, ckey, alph1, alph2){
	let at = [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63];
	let b = 0;
	for (let i = 0; i < nkey.length; i++) {
		b += nkey[i];
	}
	b = b % 64;
	let ai = key.length % 31;
	let a = at[ai];
	let starter = affineEncrypt(alph2, a, b, alph1, alph2);
	for (let i = 0; i < ckey.length; i++) {
		starter = starter.replace(ckey[i], '');
		starter = ckey[i] + starter;
	}
	let tempckey = Array.from(new Set(text.split(''))).join("");
	let tempckey2 = "";
	if(text.length >= 4){
		tempckey = text.substring(0, 4);
		tempckey2 = reverseString(text);
		tempckey2 = tempckey2.substring(0, 7);
	}
	starter = chunk(starter, 1);
	psq = {};
	psqn = {};
	let q = 0;
	for (let i = 0; i < 8; i++) {
		psq[i] = [];
		for (let j = 0; j < 8; j++) {
			psq[i][j] = starter[q];
			psqn[starter[q]] = [i,j];
			q = q + 1;
		}
	}
	r = "";
	for (let i = 0; i < text.length; i++) {
		r += psqn[text[i]].join("");
	}
	r = chunk(r, text.length);
	let fin = "";
	for (let i = 0; i < text.length; i++) {
		fin += psq[r[0][i]][r[1][i]];
	}
	return fin;
}
function compres(text){
	let t = text.length - 1;
	let start = 0;
	let end = 2;
	let data = {};
	let stest = 0;
	let etest = 2;
	let point = "";
	let test = "";
	let val = 0;
	let pv = 1;
	let p ="";
	for (let i = 0; i < t; i++) {
		start = i + 0;
		end = i + 2;
		stest = 0;
		etest = 2;
		point = text.substring(start, end);
		val = 0;
		for (let j = 0; j < t; j++) {
			stest = j + 0;
			etest = j + 2;
			test = text.substring(stest, etest);
			if(test == point){
				val += 1;
			}
		}
		if(val > 2){
			if(point[0] != "i" && point[0] != "g" && point[1] != "i" && point[1] != "g"){
				data[point] = val;
			}
		}
	}
	//console.log(data);
	/*let hi = 0;
	let low = 0;
	for (let key in data) {
		if(data[key] > 3){
			hi = hi + 1;
		}
		else{
			low = low + 1;
			//console.log(key + " - " + low)
		}
	}*/
	//console.log("high: " + hi + " low: " + low);
	let cicon = ["-", "~"];
	for (let i = 0; i < cicon.length; i++) {
		pv = 1;
		p = "";
		for (let key in data) {
			if(data[key] > pv){
				pv = data[key];
				p = key;
			}
		}
		if(p != ""){
			text = text.replace(p, "$");
			text = text.split(p).join(cicon[i]);
			let tempf = cicon[i] + p;
			text = text.replace("$", tempf);
			console.log(cicon[i] + p);
			data[p] = 0;
		}
	}
	return text;
}
function decompres(t){
	text = t.split("");
	let cicon = ["-", "~"];
	let cif = [];
	for (let i = 0; i < cicon.length; i++) {
		cif[i] = "y";
	}
	let st = 0;
	let end = 0;
	for (let i = 0; i < text.length; i++) {
		for (let j = 0; j < cicon.length; j++) {
			if(text[i] == cicon[j]){
				if(cif[j] === "y"){
					st = i + 1;
					end = i + 2;
					cif[j] = text[st] + text[end];
					text[i] = "";
				}
				else{
					text[i] = cif[j];
				}
			}
		}
	}
	text = text.join("");
	return text;
}
function enc(key, text, alph2){
	alph2 = alph2.split("");
	alph1 = {};
	for (let index = 0; index < alph2.length; ++index) {
		tempi = index + 1;
		alph1[alph2[index]] = tempi;
	}
	let okey = key;
	let ckey = Array.from(new Set(key.split(''))).join("");
	let tkey = "";
	let nkey = [];
	key = key.split("");
	for (let index = 0; index < key.length; ++index) {
		if(key[index] == "0" || key[index] == "1" || key[index] == "2" || key[index] == "3" || key[index] == "4" || key[index] == "5" || key[index] == "6" || key[index] == "7" || key[index] == "8" || key[index] == "9"){
			nkey.push(key[index]);
		}
		else if(key[index] == "a" || key[index] == "b" || key[index] == "c" || key[index] == "d" || key[index] == "e" || key[index] == "f" || key[index] == "g" || key[index] == "h" || key[index] == "i" || key[index] == "j" || key[index] == "k" || key[index] == "l" || key[index] == "m" || key[index] == "n" || key[index] == "o" || key[index] == "p" || key[index] == "q" || key[index] == "r" || key[index] == "s" || key[index] == "t" || key[index] == "u" || key[index] == "v" || key[index] == "w" || key[index] == "x" || key[index] == "y" || key[index] == "z" || key[index] == "A" || key[index] == "B" || key[index] == "C" || key[index] == "D" || key[index] == "E" || key[index] == "F" || key[index] == "G" || key[index] == "H" || key[index] == "I" || key[index] == "J" || key[index] == "K" || key[index] == "L" || key[index] == "M" || key[index] == "N" || key[index] == "O" || key[index] == "P" || key[index] == "Q" || key[index] == "R" || key[index] == "S" || key[index] == "T" || key[index] == "U" || key[index] == "V" || key[index] == "W" || key[index] == "X" || key[index] == "Y" || key[index] == "Z"){
			tkey += key[index];
		}
	}
	text = reverseString(text);
	text = affineEncrypt(text, 63, tkey.length, alph1, alph2);
	text = cte(text, ckey);
	text = bife(text, okey, nkey, ckey, alph1, alph2);
	text = encryptRailFence(text, 5);
	text = trie(text, okey, nkey, ckey, alph1, alph2);
	text = encryptRailFence(text, 4);
	text = sene(text, okey, nkey, ckey, alph1, alph2);
	text = autoe(text, tkey, okey, alph1, alph2);
	text = encryptRailFence(text, 3);
	return text;
}
function dec(key, text, alph2){
	alph2 = alph2.split("");
	alph1 = {};
	for (let index = 0; index < alph2.length; ++index) {
		tempi = index + 1;
		alph1[alph2[index]] = tempi;
	}
	let okey = key;
	let ckey = Array.from(new Set(key.split(''))).join("");
	let tkey = "";
	let nkey = [];
	key = key.split("");
	for (let index = 0; index < key.length; ++index) {
		if(key[index] == "0" || key[index] == "1" || key[index] == "2" || key[index] == "3" || key[index] == "4" || key[index] == "5" || key[index] == "6" || key[index] == "7" || key[index] == "8" || key[index] == "9"){
			nkey.push(key[index]);
		}
		else if(key[index] == "a" || key[index] == "b" || key[index] == "c" || key[index] == "d" || key[index] == "e" || key[index] == "f" || key[index] == "g" || key[index] == "h" || key[index] == "i" || key[index] == "j" || key[index] == "k" || key[index] == "l" || key[index] == "m" || key[index] == "n" || key[index] == "o" || key[index] == "p" || key[index] == "q" || key[index] == "r" || key[index] == "s" || key[index] == "t" || key[index] == "u" || key[index] == "v" || key[index] == "w" || key[index] == "x" || key[index] == "y" || key[index] == "z" || key[index] == "A" || key[index] == "B" || key[index] == "C" || key[index] == "D" || key[index] == "E" || key[index] == "F" || key[index] == "G" || key[index] == "H" || key[index] == "I" || key[index] == "J" || key[index] == "K" || key[index] == "L" || key[index] == "M" || key[index] == "N" || key[index] == "O" || key[index] == "P" || key[index] == "Q" || key[index] == "R" || key[index] == "S" || key[index] == "T" || key[index] == "U" || key[index] == "V" || key[index] == "W" || key[index] == "X" || key[index] == "Y" || key[index] == "Z"){
			tkey += key[index];
		}
	}
	text = decryptRailFence(text, 3);
	text = autod(text, tkey, okey, alph1, alph2);
	text = send(text, okey, nkey, ckey, alph1, alph2);
	text = decryptRailFence(text, 4);
	text = trid(text, okey, nkey, ckey, alph1, alph2);
	text = decryptRailFence(text, 5);
	text = bifd(text, okey, nkey, ckey, alph1, alph2);
	text = ctd(text, ckey);
	text = affineDecrypt(text, 63, tkey.length, alph1, alph2);
	text = reverseString(text);
	return text;
}
function en(){
	let key = document.getElementById("key").value;
	key = key.trim();
	//key = sani(key);
	//console.log("Key: " + key);
	let text = document.getElementById("text").value;
	text = text.toLowerCase();
	text = text.trim();
	text = text.replace(/[\n\r]+/g, '');
	text = text.replace(/\s{2,10}/g, ' ');
	document.getElementById("input").innerHTML = "Input: " + text.length + " chars";
	text = sani(text);
	/*text = text.replace(/!/g, ".");
	text = text.replace(/?/g, ".");
	text = text.replace(/@/g, "at");
	text = text.replace(/&/g, "and");*/
	text = text.replace(/ /g, "_");
	text = text.replace(/hat/g, "1");
	text = text.replace(/all/g, "2");
	text = text.replace(/ing/g, "3");
	text = text.replace(/ati/g, "4");
	text = text.replace(/tio/g, "5");
	text = text.replace(/ent/g, "6");
	text = text.replace(/ion/g, "7");
	text = text.replace(/ing/g, "8");
	text = text.replace(/and/g, "9");
	text = text.replace(/the/g, "0");
	text = text.replace(/ha/g, "A");
	text = text.replace(/se/g, "B");
	text = text.replace(/ng/g, "C");
	text = text.replace(/nt/g, "D");
	text = text.replace(/to/g, "E");
	text = text.replace(/st/g, "F");
	text = text.replace(/ar/g, "G");
	text = text.replace(/al/g, "H");
	text = text.replace(/it/g, "I");
	text = text.replace(/is/g, "J");
	text = text.replace(/ed/g, "K");
	text = text.replace(/of/g, "L");
	text = text.replace(/te/g, "M");
	text = text.replace(/or/g, "N");
	text = text.replace(/es/g, "O");
	text = text.replace(/ti/g, "P");
	text = text.replace(/en/g, "Q");
	text = text.replace(/on/g, "R");
	text = text.replace(/at/g, "S");
	text = text.replace(/nd/g, "T");
	text = text.replace(/re/g, "U");
	text = text.replace(/an/g, "V");
	text = text.replace(/er/g, "W");
	text = text.replace(/in/g, "X");
	text = text.replace(/he/g, "Y");
	text = text.replace(/th/g, "Z");
	text = encryptRailFence(text, 2);
	text = enc(key7, text, alp1);
	text = encryptRailFence(text, 3);
	text = enc(key512, text, alp2);
	text = encryptRailFence(text, 4);
	text = enc(key, text, alp3);
	text = encryptRailFence(text, 5);
	text = enc(key512, text, alp4);
	text = encryptRailFence(text, 6);
	revkey = reverseString(key);
	text = enc(revkey, text, alp5);
	text = encryptRailFence(text, 7);
	text = enc(key255, text, alp6);
	text = encryptRailFence(text, 8);
	md5 = CryptoJS.MD5(key).toString();
	text = enc(md5, text, alp7);
	text = encryptRailFence(text, 9);
	text = enc(key200, text, alp8);
	text = encryptRailFence(text, 8);
	sha1 = CryptoJS.SHA1(key).toString();
	text = enc(sha1, text, alp9);
	text = encryptRailFence(text, 7);
	text = enc(key117, text, alp10);
	text = encryptRailFence(text, 6);
	sha256 = CryptoJS.SHA256(key).toString();
	text = enc(sha256, text, alp11);
	text = encryptRailFence(text, 5);
	text = enc(key71, text, alp12);
	text = encryptRailFence(text, 4);
	sha512 = CryptoJS.SHA512(key).toString();
	text = enc(sha512, text, alp13);
	text = encryptRailFence(text, 3);
	text = enc(key36, text, alp14);
	text = encryptRailFence(text, 2);
	text = compres(text);
	text = encryptRailFence(text, 3);
	//text = affineEncrypt(text, 47, 3, alpf1, alpf2);
	//text = CryptoJS.AES.encrypt(text, key).toString();
	//text = LZString.compressToUTF16(text)
	document.getElementById("code").innerHTML = text;
	document.getElementById("output").innerHTML = "Output: " + text.length + " chars";
	new QRCode(document.getElementById("qrcode"), text);
	function download1(){
	let rtf = ""; /*"{\rtf1\ansi\deff3\adeflang1025";
 rtf += "{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\froman\fprq2\fcharset2 Symbol;}{\f2\fswiss\fprq2\fcharset0 Arial;}{\f3\froman\fprq2\fcharset0 Liberation Serif{\*\falt Times New Roman};}{\f4\froman\fprq2\fcharset0 Liberation Sans{\*\falt Arial};}{\f5\froman\fprq2\fcharset0 Times New Roman;}{\f6\fnil\fprq2\fcharset0 0;}{\f7\fnil\fprq2\fcharset0 Noto Sans CJK SC;}{\f8\fnil\fprq2\fcharset0 Lohit Devanagari;}}";
rtf += "{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}";
rtf += "{\stylesheet{\s0\snext0\rtlch\af8\afs24\alang1081 \ltrch\lang1033\langfe2052\hich\af3\loch\ql\nowidctlpar\hyphpar0\ltrpar\cf0\f3\fs24\lang1033\kerning1\dbch\af6\langfe2052 Normal;}";
rtf += "{\s15\sbasedon0\snext16\rtlch\af8\afs28\alang1081 \ltrch\lang1033\langfe2052\hich\af4\loch\ql\nowidctlpar\hyphpar0\sb240\sa120\keepn\ltrpar\cf0\f4\fs28\lang1033\kerning1\dbch\af7\langfe2052 Heading;}";
rtf += "{\s16\sbasedon0\snext16\rtlch\af8\afs24\alang1081 \ltrch\lang1033\langfe2052\hich\af3\loch\ql\sl276\slmult1\nowidctlpar\hyphpar0\sb0\sa140\ltrpar\cf0\f3\fs24\lang1033\kerning1\dbch\af6\langfe2052 Text Body;}";
rtf += "{\s17\sbasedon16\snext17\rtlch\af8\afs24\alang1081 \ltrch\lang1033\langfe2052\hich\af3\loch\ql\sl276\slmult1\nowidctlpar\hyphpar0\sb0\sa140\ltrpar\cf0\f3\fs24\lang1033\kerning1\dbch\af6\langfe2052 List;}";
rtf += "{\s18\sbasedon0\snext18\rtlch\af8\afs24\alang1081\ai \ltrch\lang1033\langfe2052\hich\af3\loch\ql\nowidctlpar\hyphpar0\sb120\sa120\ltrpar\cf0\f3\fs24\lang1033\i\kerning1\dbch\af6\langfe2052 Caption;}";
rtf += "{\s19\sbasedon0\snext19\rtlch\af8\afs24\alang1081 \ltrch\lang1033\langfe2052\hich\af3\loch\ql\nowidctlpar\hyphpar0\ltrpar\cf0\f3\fs24\lang1033\kerning1\dbch\af6\langfe2052 Index;}";
rtf += "}{\*\generator LibreOffice/7.3.7.2$Linux_X86_64 LibreOffice_project/30$Build-2}{\info{\doccomm ";*/
rtf += text;
/*rtf += "}{\creatim\yr0\mo0\dy0\hr0\min0}{\revtim\yr2024\mo4\dy5\hr10\min21}{\printim\yr0\mo0\dy0\hr0\min0}}{\*\userprops}\deftab720";
rtf += "\hyphauto1\viewscale100";
rtf += "{\*\pgdsctbl";
rtf += "{\pgdsc0\pgdscuse451\pgwsxn12240\pghsxn15840\marglsxn1440\margrsxn1440\margtsxn1440\margbsxn1440\pgdscnxt0 Default Page Style;}}";
rtf += "\formshade\paperh15840\paperw12240\margl1440\margr1440\margt1440\margb1440\sectd\sbknone\pgndec\sftnnar\saftnnrlc\sectunlocked1\pgwsxn12240\pghsxn15840\marglsxn1440\margrsxn1440\margtsxn1440\margbsxn1440\ftnbj\ftnstart1\ftnrstcont\ftnnar\aenddoc\aftnrstcont\aftnstart1\aftnnrlc";
rtf += "{\*\ftnsep\chftnsep}\pgndec\pard\plain \s0\rtlch\af8\afs24\alang1081 \ltrch\lang1033\langfe2052\hich\af3\loch\ql\nowidctlpar\hyphpar0\ltrpar\cf0\f3\fs24\lang1033\kerning1\dbch\af6\langfe2052\qc{\hich\af5\loch\fs60\f5\loch";
rtf += "Hello, World! }"
rtf += "\par \pard\plain \s0\rtlch\af8\afs24\alang1081 \ltrch\lang1033\langfe2052\hich\af3\loch\ql\nowidctlpar\hyphpar0\ltrpar\cf0\f3\fs24\lang1033\kerning1\dbch\af6\langfe2052\ql{\hich\af5\loch\fs44\f5\loch";
rtf += "First Section }";
rtf += "\par \pard\plain \s0\rtlch\af8\afs24\alang1081 \ltrch\lang1033\langfe2052\hich\af3\loch\ql\nowidctlpar\hyphpar0\ltrpar\cf0\f3\fs24\lang1033\kerning1\dbch\af6\langfe2052\ql\li0\ri0\lin0\rin0\fi720{\hich\af5\loch\f5\loch";
rtf += "This is the text in the first section. I want to write so much more. What should my next line be about. Who know! Anyway thank you for reading this.}";
rtf += "\par \pard\plain \s0\rtlch\af8\afs24\alang1081 \ltrch\lang1033\langfe2052\hich\af3\loch\ql\nowidctlpar\hyphpar0\ltrpar\cf0\f3\fs24\lang1033\kerning1\dbch\af6\langfe2052\ql\li0\ri0\lin0\rin0\fi720\loch";

rtf += "\par \pard\plain \s0\rtlch\af8\afs24\alang1081 \ltrch\lang1033\langfe2052\hich\af3\loch\ql\nowidctlpar\hyphpar0\ltrpar\cf0\f3\fs24\lang1033\kerning1\dbch\af6\langfe2052\ql\li0\ri0\lin0\rin0\fi720{\loch";
rtf += "What a great day.}";
rtf += "\par }";*/
	var element = document.createElement('a');
  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(rtf));
  element.setAttribute('download', "hello.txt");
   element.style.display = 'none';
  document.body.appendChild(element);

  element.click();

  document.body.removeChild(element);
}
  let btnlist = document.getElementById("btnlist").innerHTML;
  //document.getElementById("btnlist").innerHTML = btnlist + ' <button class="btn btn-dark" onclick="download1()">Download txt</button>';
}
function de(){
	let key = document.getElementById("key").value;
	key = key.trim();
	let text = document.getElementById("text").value;
	text = text.trim();
	//text = LZString.decompressFromUTF16(text);
	//text = CryptoJS.AES.decrypt(text, key).toString(CryptoJS.enc.Utf8);
	//text = affineDecrypt(text, 47, 3, alpf1, alpf2);
	text = decryptRailFence(text, 3);
	text = decompres(text);
	text = decryptRailFence(text, 2);
	text = dec(key36, text, alp14);
	text = decryptRailFence(text, 3);
	sha512 = CryptoJS.SHA512(key).toString();
	text = dec(sha512, text, alp13);
	text = decryptRailFence(text, 4);
	text = dec(key71, text, alp12);
	text = decryptRailFence(text, 5);
	sha256 = CryptoJS.SHA256(key).toString();
	text = dec(sha256, text, alp11);
	text = decryptRailFence(text, 6);
	text = dec(key117, text, alp10);
	text = decryptRailFence(text, 7);
	sha1 = CryptoJS.SHA1(key).toString();
	text = dec(sha1, text, alp9);
	text = decryptRailFence(text, 8);
	text = dec(key200, text, alp8);
	text = decryptRailFence(text, 9);
	md5 = CryptoJS.MD5(key).toString();
	text = dec(md5, text, alp7);
	text = decryptRailFence(text, 8);
	text = dec(key255, text, alp6);
	text = decryptRailFence(text, 7);
	revkey = reverseString(key);
	text = dec(revkey, text, alp5);
	text = decryptRailFence(text, 6);
	text = dec(key512, text, alp4);
	text = decryptRailFence(text, 5);
	text = dec(key, text, alp3);
	text = decryptRailFence(text, 4);
	text = dec(key512, text, alp2);
	text = decryptRailFence(text, 3);
	text = dec(key7, text, alp1);
	text = decryptRailFence(text, 2);
	text = text.replace(/Z/g, "th");
	text = text.replace(/Y/g, "he");
	text = text.replace(/X/g, "in");
	text = text.replace(/W/g, "er");
	text = text.replace(/V/g, "an");
	text = text.replace(/U/g, "re");
	text = text.replace(/T/g, "nd");
	text = text.replace(/S/g, "at");
	text = text.replace(/R/g, "on");
	text = text.replace(/Q/g, "en");
	text = text.replace(/P/g, "ti");
	text = text.replace(/O/g, "es");
	text = text.replace(/N/g, "or");
	text = text.replace(/M/g, "te");
	text = text.replace(/L/g, "of");
	text = text.replace(/K/g, "ed");
	text = text.replace(/J/g, "is");
	text = text.replace(/I/g, "it");
	text = text.replace(/H/g, "al");
	text = text.replace(/G/g, "ar");
	text = text.replace(/F/g, "st");
	text = text.replace(/E/g, "to");
	text = text.replace(/D/g, "nt");
	text = text.replace(/C/g, "ng");
	text = text.replace(/B/g, "se");
	text = text.replace(/A/g, "ha");
	text = text.replace(/0/g, "the");
	text = text.replace(/9/g, "and");
	text = text.replace(/8/g, "ing");
	text = text.replace(/7/g, "ion");
	text = text.replace(/6/g, "ent");
	text = text.replace(/5/g, "tio");
	text = text.replace(/4/g, "ati");
	text = text.replace(/3/g, "ing");
	text = text.replace(/2/g, "all");
	text = text.replace(/1/g, "hat");
	text = text.replace(/_/g, " ");
	document.getElementById("code").innerHTML = text;
}
